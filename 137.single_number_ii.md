#### [137.只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
>
> **说明：**
>
> 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>
> **示例 1:**
>
> ```
> 输入: [2,2,3,2]
> 输出: 3
> ```
>
> **示例 2:**
>
> ```
> 输入: [0,1,0,1,0,1,99]
> 输出: 99
> ```

**简单思路**

采用字典对整数的出现次数进行统计即可。时间复杂度略大于$O(n)$，空间开销很大，执行时间60ms

```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        hashMap = {}
        
        for number in nums:
            try:
                hashMap[number] += 1
            except:
                hashMap[number] = 1
            
        for number, cnt in hashMap.items():
            if cnt == 1:
                return number
```

**然而**

考虑位运算，使用```00,01,10,00```对数字的出现次数进行表示即可完成算法。使用```ab```来表示这四个二元组，则当且仅当```b=1```时，数字只出现一次。观察异或操作，发现```0^0=0, 0^1=1, 1^1=0 ```，恰好符合前三个```b```，故考虑结合```a```，在不影响当前结果的情况下，将第四个```b```确定下来。由于当```b=1```时，```a=0```，想要保持结果为```1```，可考虑```b^a, b&(~a)```等，当组合为```10```时，结果应当为```0```，而```0^1=1```不满足，``` 0^(~1)=0```满足。

故位操作为```b=(b^x)&(~a)```，为此，需要确定```a```，而对于```a```，发现其与```b```相比，延迟了一次操作，换而言之，```b```的出现顺序为```0, 1, 0, 0```，将其往右延迟一次操作，左边空缺补```0```，变成```0, 0, 1, 0, 0```，则为```a```的出现顺序，故只需先令```a=0```，并在计算的时候采用先计算```b```，后采用同样的算法计算```a```的方式，即得出结果。时间复杂度$O(n)$，仅使用两个临时变量空间复杂度为$O(1)$。执行时间48ms

```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        # 00 01 10 00 -> ab
        a, b = 0, 0
        
        for number in nums:
            b = (b ^ number) & (~a)
            a = (a ^ number) & (~b)
        
        return b
```

这类题目都应该优先考虑位运算，唉，我还是太年轻。