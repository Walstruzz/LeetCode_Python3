#### 0605.种花问题

[题目链接](https://leetcode-cn.com/problems/can-place-flowers)

> 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 **n** 。能否在不打破种植规则的情况下种入 **n** 朵花？能则返回True，不能则返回False。
>
> **示例 1:**
>
> ```
> 输入: flowerbed = [1,0,0,0,1], n = 1
> 输出: True
> ```
>
> **示例 2:**
>
> ```
> 输入: flowerbed = [1,0,0,0,1], n = 2
> 输出: False
> ```
>
> **注意:**
>
> 1. 数组内已种好的花不会违反种植规则。
> 2. 输入的数组长度范围为 [1, 20000]。
> 3. **n** 是非负整数，且不会超过输入数组的大小。

**简单思路**

计算两朵花之间的花盆数，即```1```和```1```之间的```0```的个数```cnt_range```，显然在此区间中可种的花数目为```(cnt_range - 1) // 2```。防御式编程思想，先在```flowerbed```左右添加```[1, 0]```和```[0, 1]```以避免处理边界条件。时间复杂度$O(n)$，空间复杂度$O(1)$，执行时间72ms

```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [1, 0] + flowerbed + [0, 1]
        
        cnt, cnt_range = 0, 0
        for i in flowerbed:
            if cnt >= n:
                break
                
            if i == 0:
                cnt_range += 1
            else:
                if cnt_range > 0:
                    cnt += (cnt_range - 1) // 2
                    cnt_range = 0
        
        return cnt >= n
```

