#### 0258.各位相加

[题目链接](https://leetcode-cn.com/problems/add-digits)

> 给定一个非负整数 `num`，反复将各个位上的数字相加，直到结果为一位数。
>
> **示例:**
>
> `
> 输入: 38
> 输出: 2 
> 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
> `
>
> **进阶:**
> 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

**简单思路**

暴力求解，执行时间72ms

```python
class Solution:
    def addDigits(self, num: int) -> int:
        while num // 10 > 0:
            tmp, num = num, 0
            
            while tmp > 0:
                num += tmp % 10
                tmp //= 10
        
        return num
```

**然而**

要使用$O(1)$时间复杂度解决问题，就要把问题转换为公式。举例，假设`num`各位为`a, b, c, d`，即`num = a * 1000 + b ** 100 + c * 10 + d`，那么，各位加起来的值为`a + b + c + d`，而`num == a * 1000 + b ** 100 + c * 10 + d == (a + b + c + d) + (a * 999 + b * 99 + c * 9) ==  (a + b + c + d) + 9 * (a * 111 + b * 11 + c * 1)`，下面证明`(a + b + c + d) < (a * 111 + b * 11 + c * 1)`，对于三位数及三位数以上的例子，是显然的成立的，可以得到`(a + b + c + d)`等于`num % 9`，对于二位数和一位数的例子，枚举可以发现也是满足这个结果的。

其中有一些特殊例子，即当`num`为`9`的倍数时，结果应当为`9`而非`0`，以及当`num = 0`时，结果应当为`0`而非`9`。注重处理这两类即可。时间复杂度$O(1)$，空间复杂度$O(1)$

```python
class Solution:
    def addDigits(self, num: int) -> int:
        return (num - 1) % 9 + 1 if num > 0 else 0
```

